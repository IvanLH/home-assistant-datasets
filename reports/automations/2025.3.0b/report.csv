task_id,model_id,label,details
"door_left_open_door_left_open-door_left_open-1","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e45c9580>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e45782d0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-2","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6bd28e0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f490f130 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6944d60>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f69bcd70 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-2","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f68756c0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6947610 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-3","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f65e2520>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6c6f8c0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-4","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f662b740>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4f4aab0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-3","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4fb0040>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4ee1e50 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-4","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4c0be20>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6666390 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-0","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4b6de40>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4b8a270 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-0","gemini-1.5-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4ae3a60>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4a973b0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-0","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e489b880>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e482a090 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e43ec4a0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e48c0650 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-2","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4b0bec0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4920ad0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-3","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4c77e20>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4c84230 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-4","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f48809a0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4faad50 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-0","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6cda520>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f68cfdd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-1","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f48d3920>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6892bd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-2","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4b13c40>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4f4b470 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-3","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4f1e5c0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6a0d8b0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-4","gpt-4o","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f66b3600>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f4b79250 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4d17880>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4829df0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-3","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6818900>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f68da690 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f681a8e0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4571310 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-2","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4df4cc0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f677e090 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-3","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e561dbc0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e5785fd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-4","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5411e40>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e558fe30 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-0","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4df6700>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e42cd7f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-0","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4b13920>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4d81cd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-1","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f492bf60>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f4b8cd70 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4b6f7e0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f68fc830 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-0","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e43edf80>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6650a10 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e563d120>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4fa8e30 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-2","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e57f0ea0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f68914f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-3","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6b39da0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4a94830 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-4","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4283600>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e490ba70 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-0","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4cb7380>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e43439b0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-1","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4806ca0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e48a3dd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-2","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4f0d120>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4e6d490 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-3","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4a7e480>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6a2df10 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-4","gemini-2.0-flash","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4fca2a0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4a3e9f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(MEDIA_PLAYER_ENTITY) == 'off'
        assert not media_player_state_change.is_set()
    
        # Open the door and verify that no other states have changed.
        hass.states.async_set(DOOR_ENTITY, 'on')
        await asyncio.sleep(0.01)
    
        expected_states = {**states, DOOR_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # The door has been left open for too long
        async_fire_time_changed(hass, datetime.datetime.now() + OPEN_DURATION)
    
        # Wait for the media player to start playing to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await media_player_state_change.wait()

datasets/automations/door_left_open/test_blueprint.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30e4a3e9f0 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4fca2a0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4a3e9f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(MEDIA_PLAYER_ENTITY) == 'off'
        assert not media_player_state_change.is_set()
    
        # Open the door and verify that no other states have changed.
        hass.states.async_set(DOOR_ENTITY, 'on')
        await asyncio.sleep(0.01)
    
        expected_states = {**states, DOOR_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # The door has been left open for too long
        async_fire_time_changed(hass, datetime.datetime.now() + OPEN_DURATION)
    
        # Wait for the media player to start playing to turn off
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/door_left_open/test_blueprint.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30e53a16c0>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4fca2a0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4a3e9f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(MEDIA_PLAYER_ENTITY) == 'off'
        assert not media_player_state_change.is_set()
    
        # Open the door and verify that no other states have changed.
        hass.states.async_set(DOOR_ENTITY, 'on')
        await asyncio.sleep(0.01)
    
        expected_states = {**states, DOOR_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # The door has been left open for too long
        async_fire_time_changed(hass, datetime.datetime.now() + OPEN_DURATION)
    
        # Wait for the media player to start playing to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await media_player_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for media player state change') from err
E           TimeoutError: Timeout waiting for media player state change

datasets/automations/door_left_open/test_blueprint.py:94: TimeoutError"
"light_on_door_light_on_door-light_on_door-0","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4de4220>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e577f230 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e57ddc60>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e42020f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-2","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5410cc0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e56e0530 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-3","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4b2a0c0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e552f590 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-4","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f68e80e0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6ce0e30 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-0","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6bd3560>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f693acf0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-1","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4898540>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f69eaab0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-2","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e48267a0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f66512b0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-3","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4ce6020>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f689b8f0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-4","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4c8eca0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f68cc9b0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-0","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6bd02c0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4fabef0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6819760>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f4b79c10 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e57def20>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6b6a150 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-3","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e4f83100>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f68c5010 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f4929b20>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4d803b0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-0","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6a07ec0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e57c8dd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-1","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e42cbe20>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e4200f50 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-2","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f67aa5c0>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e5042bd0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-3","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30f66b2700>
media_player_state_change = <asyncio.locks.Event object at 0x7f30f6a63bf0 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"door_left_open_door_left_open-door_left_open-4","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = False, get_state = <function get_state_fixture.<locals>.func at 0x7f30e57dd300>
media_player_state_change = <asyncio.locks.Event object at 0x7f30e541d070 [unset]>

    async def test_door_open_plays_media(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        media_player_state_change: asyncio.Event,
    ) -> None:
        '''Test the media is played when the door is left open.'''
>       assert automation, 'Automation failed to setup'
E       AssertionError: Automation failed to setup
E       assert False

datasets/automations/door_left_open/test_blueprint.py:72: AssertionError"
"light_on_door_light_on_door-light_on_door-1","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-2","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-3","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-4","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-3","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-0","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-1","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-0","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-1","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-3","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-4","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-1","gpt-4o-mini","Good","None"
"light_on_door_light_on_door-light_on_door-3","gpt-4o-mini","Good","None"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-haiku","Good","None"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-haiku","Good","None"
"light_on_door_light_on_door-light_on_door-1","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-2","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-3","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-4","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-3","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6f6b4c0>
light_state_change = <asyncio.locks.Event object at 0x7f30f4b8f110 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30f4b8f110 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6f6b4c0>
light_state_change = <asyncio.locks.Event object at 0x7f30f4b8f110 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30c2601b80>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30f6f6b4c0>
light_state_change = <asyncio.locks.Event object at 0x7f30f4b8f110 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:128: TimeoutError"
"light_on_door_light_on_door-light_on_door-0","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-1","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-0","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-1","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-3","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-4","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-1","gpt-4o-mini","Good","None"
"light_on_door_light_on_door-light_on_door-3","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e42ade40>
light_state_change = <asyncio.locks.Event object at 0x7f30f68adb50 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30f68adb50 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e42ade40>
light_state_change = <asyncio.locks.Event object at 0x7f30f68adb50 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30e498c9c0>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e42ade40>
light_state_change = <asyncio.locks.Event object at 0x7f30f68adb50 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:128: TimeoutError"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5351760>
light_state_change = <asyncio.locks.Event object at 0x7f30f6a0da30 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30f6a0da30 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5351760>
light_state_change = <asyncio.locks.Event object at 0x7f30f6a0da30 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30c365c280>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5351760>
light_state_change = <asyncio.locks.Event object at 0x7f30f6a0da30 [unset]>

    async def test_door_open_close(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # After 30 seconds the door closes. We expect the light to also turn off.
        async_fire_time_changed(
            hass, datetime.datetime.now() + datetime.timedelta(seconds=30)
        )
        hass.states.async_set(DOOR_ENTITY, 'off')
    
        # Wait for the light to turn off
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:128: TimeoutError"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-haiku","Good","None"
"light_on_door_light_on_door-light_on_door-1","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-2","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-3","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-4","gpt-4o","Good","None"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-3","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30c350b060>
light_state_change = <asyncio.locks.Event object at 0x7f30c3460d70 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30c3460d70 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30c350b060>
light_state_change = <asyncio.locks.Event object at 0x7f30c3460d70 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30e53dd380>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30c350b060>
light_state_change = <asyncio.locks.Event object at 0x7f30c3460d70 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:170: TimeoutError"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-sonnet","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5f3e660>
light_state_change = <asyncio.locks.Event object at 0x7f30e5f10ef0 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30e5f10ef0 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5f3e660>
light_state_change = <asyncio.locks.Event object at 0x7f30e5f10ef0 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30e5f1c500>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5f3e660>
light_state_change = <asyncio.locks.Event object at 0x7f30e5f10ef0 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:170: TimeoutError"
"light_on_door_light_on_door-light_on_door-0","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-1","claude-3-5-sonnet","Good","None"
"light_on_door_light_on_door-light_on_door-0","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-1","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-3","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-4","gemini-2.0-flash","Good","None"
"light_on_door_light_on_door-light_on_door-1","gpt-4o-mini","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5189080>
light_state_change = <asyncio.locks.Event object at 0x7f30c1f01d30 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30c1f01d30 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5189080>
light_state_change = <asyncio.locks.Event object at 0x7f30c1f01d30 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30e42b4880>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30e5189080>
light_state_change = <asyncio.locks.Event object at 0x7f30c1f01d30 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:170: TimeoutError"
"light_on_door_light_on_door-light_on_door-3","gpt-4o-mini","Good","None"
"light_on_door_light_on_door-light_on_door-2","claude-3-5-haiku","Bad","hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30c354fec0>
light_state_change = <asyncio.locks.Event object at 0x7f30e482a090 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
>               await light_state_change.wait()

datasets/automations/light_on_door/test_blueprint.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x7f30e482a090 [unset]>

    async def wait(self):
        '''Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        '''
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30c354fec0>
light_state_change = <asyncio.locks.Event object at 0x7f30e482a090 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
>           async with asyncio.timeout(WAIT_TIMEOUT_SEC):

datasets/automations/light_on_door/test_blueprint.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError()
exc_tb = <traceback object at 0x7f30c36cd380>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

/home/vscode/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/lib/python3.13/asyncio/timeouts.py:116: TimeoutError

The above exception was the direct cause of the following exception:

hass = <HomeAssistant RUNNING>, automation = True, get_state = <function get_state_fixture.<locals>.func at 0x7f30c354fec0>
light_state_change = <asyncio.locks.Event object at 0x7f30e482a090 [unset]>

    async def test_light_timeout(
        hass: HomeAssistant,
        automation: bool,
        get_state: Callable[[], dict[str, EntityState]],
        light_state_change: asyncio.Event,
    ) -> None:
        '''Test the light is controlled by opening and closing the door.'''
        assert automation, 'Automation failed to setup'
        states = get_state()
        assert states.get(DOOR_ENTITY) == 'off'
        assert states.get(LIGHT_ENTITY) == 'off'
    
        assert not light_state_change.is_set()
    
        # Open the door and wait for the light to turn on
        hass.states.async_set(DOOR_ENTITY, 'on')
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
        except TimeoutError as err:
            raise TimeoutError('Timeout waiting for light to turn on') from err
    
        expected_states = {**states, DOOR_ENTITY: 'on', LIGHT_ENTITY: 'on'}
        assert get_state() == expected_states
    
        # Yield to the automation to let it set up the idle timeout or turn off trigger.
        await asyncio.sleep(0.01)
        light_state_change.clear()
    
        # Wait for some timeout and verify the light has been automatically turned off.
        async_fire_time_changed(hass, datetime.datetime.now() + LIGHT_TIMEOUT)
        try:
            async with asyncio.timeout(WAIT_TIMEOUT_SEC):
                await light_state_change.wait()
                await hass.async_block_till_done()
        except TimeoutError as err:
>           raise TimeoutError('Timeout waiting for light to turn off') from err
E           TimeoutError: Timeout waiting for light to turn off

datasets/automations/light_on_door/test_blueprint.py:170: TimeoutError"
"light_on_door_light_on_door-light_on_door-4","claude-3-5-haiku","Good","None"
